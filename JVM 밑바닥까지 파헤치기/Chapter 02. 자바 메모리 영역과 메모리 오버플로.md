# Chapter 02. 자바 메모리 영역과 메모리 오버플로

## 2.2 런타임 데이터 영역

- JVM은 자바 프로그램을 실행하는 동안 필요한 메모리를 몇 개의 데이터 영역으로 나눠 관리한다.

### 2.2.1 프로그램 카운터

- 작은 메모리 영역으로, 현재 실행 중인 스레드의 '바이트코드 줄 번호 표시기'라고 생각하면 쉽다.
- 프로그램의 제어 흐름, 분기, 순환, 점프 등을 표현하는 것이다.

> JVM에서의 멀티스레딩
> - JVM에서의 멀티스레딩은 CPU 코어를 여러 스레드가 교대로 사용하는 방식으로 구현되기 때문에 특정 시각에 각 코어는 한 스레드의 명령어만 실행하게 된다.
> - 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하려면 스레드 각각에는 고유한 프로그램 카운터가 필요한다.
> - 따라서 각 스레드의 카운터는 서로 영향을 주지 않는 독립된 영역에 저장된다. 이 영역을 스레드 프라이빗 메모리라 한다.

### 2.2.2 자바 가상 머신 스택

- 자바 가상 머신 스택도 '스레드 프라이빗'하다.
- 가상 머신 스택은 자바 메서드를 실행하는 스레드의 메모리 모델을 설명해 준다.

> JVM 스택
> - 각 메서드가 호출될 때마다 JVM은 스택 프레임을 만들어 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등의 정보를 저장한다. 
> - 그런 다음 스택 프레임을 가상 머신 스택에 push하고, 메서드가 끝나면 pop한다. 
> - 지역 변수 테이블에는 JVM이 컴파일 타임에 알 수 있는 다양한 기본 데이터 타입, 객체 참조, 반환 주소 타입을 저장한다. 지역 변수 테이블에서 이 테이터 타입을 저장하는 공간을 지역 변수 슬롯이라 하며, 일반적으로 슬롯 하나이 크기는 32비트다. 따라서 double 타입처럼 길이가 64비트인 데이터는 슬롯 두 개를 차지한다.

> 자바 가상 머신 명세가 정의한 스택의 두 가지 에러
> 1. StackOverflowError: 스레드가 요청한 스택 깊이가 가상 머신이 허용하는 깊이보다 클 때, 발생
> 2. OutOfMemoryError: 스택 용량을 동적으로 확장할 수 있는 JVM에서 스택을 확장하려는 시점에 여유 메모리가 부족할 때, 발생

### 2.2.3 네이티브 메서드 스택

- 가상 머신 스택과 매우 비슷한 역할을 한다. 차이점은 네이티브 메서드를 실행할 때 사용한다는 것
- 자바 가상 머신 명세는 네이티브 메서드 스택에서 메서드를 어떤 구조로 어떻게 표현해야 하는지와 관련하여 아무것도 명시하지 않았다. 따라서 가상 머신 구현자가 원하는 형태로 자유롭게 표현할 수 있다.

### 2.2.4 자바 힙

- 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리다.
- 모든 스레드가 공유하며 가상 머신이 구동될 때 만들어진다.
- 목적은 객체 인스턴스를 저장하는 것이고, 자바 세계의 거의 모든 객체 인스턴스가 이 영역에 할당된다.
- 자바 가상 머신 명세에 따르면, 자바 힙은 물리적으로 떨어진 메모리에 위치해도 상관없으나 논리적으로는 연속되어야 한다.(파일을 저장할 때 디스크 공간을 활요하는 방식과 같다.)

### 2.2.5 메서드 영역

- 메서드 영역도 자바 힙처럼 모든 스레드가 공유한다.
- 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수, JIT 컴파일러가 컴파일한 코드 캐시 등을 저장하는 데 이용된다.
- 자바 가상 머신 명세에서는 메서드 영역도 논리적으로는 힙의 한 부분으로 기술하지만, 자바 힙과 구분하기 위해 논힙이라 부르기도 한다.
- 하지만 메서드 영역에서는 쓰레기를 회수할 일이 거의 없다. 회수할 대상은 대부분 상수 풀과 타입이다.

### 2.2.6 런타임 상수 풀

- 메서드 영역의 일부다.
- 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보에 더해 컴파일탐임에 생성된 다양한 리터럴과 심벌 참조가 저장된다.
- 가상 머신이 클래스를 로드할 때 이러한 정보를 메서드 영역의 런타임 상수 풀에 저장한다.

### 2.2.7 다이렉트 메모리

- 다이렉트 메모리는 가상 머신 런타임에 속하지 않으며 자바 가상 머신 명세에 정의된 영역도 아니다.
- NIO는 힙이 아닌 메모리를 직접 할당할 수 있는 네이티브 함수 라이브러리를 이용하며, 이 메모리에 저장되어 있는 DirectByteBuffer 객체를 통해 작업을 수행할 수 있다.

## 2.3 핫스팟 가상 머신에서의 객체 들여다보기

### 2.3.1 객체 생성

> 1. 자바 가상 머신이 new 명령에 해당하는 바이트 코드를 만나면, 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인한다.
> 2. 그런 다음 이 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화되었는지 확인한다.
> 3. 로딩이 완료된 클래스라면 새 객체를 담을 메모리를 할당한다. 

- 멀티 스레딩 환경에서는 여유 메모리의 시작 포인터 위치를 수정하는 단순한 일도 스레드 안전하지 않기 때문에 여러 스레드가 동시에 객체를 생성하려고 할 때 문제가 생길 수 있다.

> 스레드 로컬 할당 버퍼(TLAB) 사용
> TLAB이 끝났으면 가상 머신은 할당받은 공간을 0으로 초기화한다.
> 스레드 로컬 할당 버퍼를 사용한다면 초기화는 TLAB 할당 시 미리 수행한다. 자바 코드에서 객체의 인스턴스 필드를 초기화하지 않고도 사용할 수 있는 이유가 이 단계 덕이다.

> ✅
> - 자바 컴파일러는 자바의 new 키워드를 발견하면 바이트 코드 명령어인 new와 invokespecial로 변환한다.
> - new는 메모리 할당 단계를 수행한다.
> - invokespecial은 <init>() 메서드 호출을 담당한다.

### 2.3.2 객체의 메모리 레이아웃

- 핫스팟 가상 머신은 객체를 세 부분으로 나눠 힙에 저장한다. 객체 헤더, 인스턴스 데이터, 길이 맞추기용 정렬 패딩이다.

#### 객체 헤더

> 핫스팟 가상 머신이 객체 헤더 담는 정보
> 첫 번째 유형, 
> - 런타임 데이터. 마크 워드라고도 한다. 차지하는 크기는 32 가상 머신에서는 32비트. 64비트 가상 머신에서는 64비트이다.
> - 참고: 편향된 스레드의 아이디, 편향된 시각의 타임스탬프는 모두 편향 락 관련 사항이라 JDK 18 이후 JDK에는 해당하지 않는다. 
> 1. 해시 코드
> 2. GC 세대 나이
> 3. 락 상태 플래그
> 4. 스레드가 점유하고 있는 락들
> 5. 편향된 스레드의 아이디
> 6. 편향된 시각의 타임스탬프
> 
> 두 번째, 클래스 워드(klass word)
> 1. 객체의 클래스 관련 메타 데이터를 가리키는 클래스 포인터
> 
> 세 번째, 배열 길이

#### 인스턴스 데이터

- 객체가 실제로 담고 있는 정보이다.
- 다양한 타입의 필드 관련 내용, 부모 클래스 유무, 부모 클래스에서 정의한 모든 필드가 이 부분에 기록된다.

#### 정렬 패딩

- 이 부분은 존재하지 않을 수도 있으며, 특별한 의미 없이 자리를 확보하는 역할만 한다.
- 핫스팟 가상 머신의 자동 메모리 관리 시스템에서 객체의 시작 주소는 반드시 8바이트의 정수배여야 한다. 달리 말하면 모든 객체의 크기가 8바이트의 정수배여야 한다는 뜻이다.
- 위 조건을 충족하지 못하는 경우에만 패딩으로 크기를 채운다.

### 2.3.3 객체에 접근하기

- 대다수 객체는 다른 객체 여러 개를 조합해 만들어진다.
- 자바 프로그램은 스택에 있는 참조 데이터를 통해 힙에 들어 있는 객체들에 접근해 이를 조작한다.

> 객체에 접근하는 방식
> 1. 핸들 방식
> - 자바 힙에 핸들 저장용 풀이 별도로 존재할 것이다. 
> - 참조에는 객체의 핸들 주소가 저장되고 핸들에는 다시 해당 객체의 인스턴스 데이터, 타입 데이터, 구조 등의 정확한 주소 정보가 담길 것이다.
> - 장점: 참조에 안정적인 핸들의 주소가 저장된다는 것이다. 가비지 컬렉션 과정에서 객체가 이동하는 일은 아주 흔하다. 핸들을 이용하면 이렇게 객체의 위치가 바뀌는 상황에서도 참조 자체는 손댈 필요가 없다.
> 
> 2. 다이렉트 포인터 방식
> - 자바 힙에 위치한 객체에서 인스턴스 데이터뿐 아니라 타입 데이터에 접근하는 길도 제공해야 한다.
> - 스택의 참조에는 객체의 식제 주소가 바로 저장되어 있다.
> - 장점: 핸들을 경유하는 오버헤드가 없기 때문에 속도가 빠르다.

- 핫스팟 VM은 주로 다이렉트 포인터 방식을 이용한다.

## 2.4 실전: OutOfMemoryError 예외

### 2.4.1 자바 힙 오버플로

- -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError 환경 설정

### 2.4.2 가상 머신 스택과 네이티브 메서드 스택 오버플로

- -Xss 매개 변수로 스택 크기 변경

### 2.4.3 메서드 영역과 런타임 상수 풀 오버플로

- String::intern() 네이티브 메서드로 실험

### 2.4.4 네이티브 다이렉트 메모리 오버플로

## 2.5 마치며
