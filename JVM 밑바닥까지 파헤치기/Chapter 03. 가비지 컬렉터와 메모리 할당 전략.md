# Chapter 03. 가비지 컬렉터와 메모리 할당 전략

- 자바 힙과 메서드 영역은 불확실한 게 아주 많다.

## 3.2 대상이 죽었는가?

- 가비지 컬렉터가 힙을 청소하려면 가장 먼저 어떤 객체가 살아 있고, 또 어떤 객체가 죽었는지 판단해야 한다.
- '죽었다'는 말은 프로그램 코드에서 어떤 식으로도 더는 사용될 수 없다는 뜻이다.

### 3.2.1 참조 카운팅 알고리즘

> 객체가 살아 있는지 판단하는 알고리즘
> 1. 객체를 가리키는 참조 카운터를 추가한다. 참조하는 곳이 하나 늘어날 때마다 카운터 값을 1씩 증가시킨다.
> 2. 참조하는 곳이 하나 사라질 때마다 카운터 값을 1씩 감소시킨다.
> 3. 카운터 값이 0이 된 객체는 더는 사용될 수 없다.

- 간단한 참조 카운팅만으로는 수환 참조 문제를 풀기 어렵다.
- 자바 가상 머신은 객체 생사 판단에 참조 카운팅 알고리즘을 사용하지 않는다.

> JVM GC 로깅
> - -Xlog:gc*

### 3.2.2 도달 가능성 분석 알고리즘

- 자바, C# 등 오늘날의 주류 프로그래밍 언어들은 모두 객체 생사 판단에 도달 가능성 분석 알고리즘을 이용한다.
- 기본 아이디어는 GC 루트라고 하는 루트 객체들을 시작 노드 집합으로 쓰는 것이다.

> 탐색 과정
> 1. 시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색해 들어간다.
> 2. 탐색 과정에서 만들어지는 경로를 참조 체인이라 하는데, 어떤 객체와 GC 루트 사이를 이어 주는 참조 체인이 없다면, GC 루트로부터 도달 불가능한 객체는 더 이상 사용할 수 없는 게 확실해진다.

> 자바에서 GC 루트로 이용할 수 있는 객체
> - 가상 머신 스택에서 참조하는 객체: 현재 실행 중인 메서드에서 쓰는 매개 변수, 지역 변수, 임시 변수 등
> - 메서드 영역에서 클래스가 정적 필드로 참조하는 객체: 자바 클래스의 참조 타입 정적 변수
> - 메서드 영역에서 상수로 참조되는 객체: 문자열 테이블 안의 참조
> - 네이티브 메서드 스택에서 JNI(네이티브 메서드)가 참조하는 객체
> - 자바 가상 머신 내부에서 쓰이는 참조: 기본 데이터 타입에 해당하는 Class 객체, 일부 상주 예외 객체, 시스템 클래스 로더
> - 동기화 락으로 잠겨 있는 모든 객체
> - 자바 가상 머신 내부 상황을 반영하는 JMXBean: JVMTI에 등록된 콜백, 로컬 코드 캐시 등

### 3.2.3 다시 참조 이야기로

> JDK 1.2부터 참조 개념이 확장되어 참조를 네 가지로 구분하기 시작했다. 나열한 순서대로 강도가 약해진다.
> 1. 강한 참조: 가장 전통적인 정의의 참조를 뜻한다. 가비지 컬렉터가 절대 회수하지 않는다.
> 2. 부드러운 참조: 유용하지만 필수는 아닌 객체를 표현한다. 메모리 오버플로가 나기 직전에 두 번째 회수를 위한 회수 목록에 추가된다. SoftReference<> 클래스가 구현하다.
> 3. 약한 참조: 부드러운 참조와 비슷하지만 연결 강도가 더 약하다. 약한 참조뿐인 객체는 다음번 가비지 컬렉션까지만 살아 있다. WeakReference<> 클래스가 구현한다.
> 4. 유령 참조: 참조 중에서 가장 약하다. 객체 수명에 아무런 영향을 주지 않으며, 유령 참조를 통해 객체 인스턴스를 가져오는 것마저 불가능하다. 대상 객체가 회수 될 때 알림을 받기 위해 사용한다. PhantomReference<> 클래스가 구현하다.

> final 참조
> - 참조 강도는 약한 참조와 유령 참조 사이다.
> - finalize() 메서드를 구현한 객체는 모두 파이널 참조의 대상이 되어 별도의 큐에 등록된다.

### 3.2.3 살았나 죽었나?

- 도달 가능성 분석 알고리즘이 도달 불가능으로 판단한 객체라고 해서 반드시 죽어야 하는 건 아니다.
- 확실한 사망 선고를 내리려면 두 번의 표시(marking) 과정을 거쳐야 한다.
- 도달 가능성 분석으로 GC 루트와 연결된 참조 체인을 찾지 못한 객체에는 첫 번째 표시가 이루어지며 이어서 필터링이 진행된다. 필터링 조건은 종료자(finalize), 즉 'finalize()를 실행해야 하는 객체인가'이다.
- finalize()를 실행해야 하는 객체로 판명되는 F-Queue라는 대기열에 추가된다.
- 가능한 한 finalize()는 사용하지 말자.

### 3.2.5 메서드 영역 회수하기

- 메서드 영역의 가비지 컬렉션은 크게 두 가지를 회수한다. 더 이상 사용하지 않는 상수와 클래스다.

> 더 이상 쓰이지 않는 클래스는 다음 세 가지 조건을 만족한다.
> - 이 클래스의 인스턴스가 모두 회수되었다. 즉, 자바 힙에는 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
> - 이 클래스를 읽어 들인 클래스 로더가 회수되었다. 이 조건은 OSGi나 JSP 리로딩처럼 세심하게 설계된 대안 클래스 로더 없이는 충족하기 어렵다.
> - 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다.

- 자바 가상 머신은 위 세 조건에 부합하는 쓸모 없는 클래스들을 회수하도록 허용한다. 허용한다고 했지, 반드시 회수한다고 하지는 않았다.
- 핫스팟 가상 머신은 클래스 회수 여부를 제어할 수 있도록 -Xnoclassgc 매개 변수를 제공한다.

## 3.3 가비지 컬렉션 알고리즘

- 상세한 이론은 The Garbage Collection Handbook 자세히 참고 바람.
- 참조 카운팅 GC와 추적 GC로 나눌 수 있다.

### 3.3.1 세대 단위 컬렉션 이론

> 기본적으로 두 가지 가정이 뿌리를 이룬다.
> 1. 약한 세대 가설: 대다수 객체는 일찍 죽는다.
> 2. 강한 세대 가설: 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.

- 자바 힙을 여러 영역으로 나누면 가비지 컬렉터는 한 번에 하나 또는 몇 개 영역만 선택해 회수할 수 있는데, 이를 기준으로 마이너 GC, 메이저 GC, 전체 GC식으로 부르곤 한다.
- 각 영역에 담긴 객체들의 생존 특정에 따라 마크-스윕, 마크-카피, 마크-컴팩트 등의 가비지 컬렉션 알고리즘을 구분해 적용한다.

> 구세대에서 참조 중인 객체도 충분히 있을 수 있다. 신세대와 구세대를 같이 탐색하는 것은 성능 면에서 부담이 크다. 이 문제를 풀려면 한 가지 가정을 더 추가해야 한다.
> 3. 세대 간 참조 가설: 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.

- 상호 참조 관계의 두 객체는 삶과 죽음을 함께하는 경향이 있다.

> 세대 단위 컬렉션에서의 다양한 GC 방식
> - 부분 GC: 자바 힙의 일부만 회수하는 가비지 컬렉션을 말하며 다음과 같이 세분화된다.
>   - 마이너 GC: 신세대만 대상으로 하는 GC
>   - 메이저 GC: 구세대만 대상으로 하는 GC
>   - 혼합 GC: 신세대 전체와 구세대 일부를 대상으로 하는 GC
> - 전체 GC: 자바 힙 전체와 메서드 영역까지 모두를 대상으로 하는 GC

### 3.3.2 마크-스윕 알고리즘

- 작업을 표시와 쓸기라는 두 단계로 나눠 진행한다.
- 회수할 객체를 모두 표시한 다음, 표시된 객체를 쓸어담는 방식이다.

> 큰 단점 두 가지
> 1. 실행 효율이 일정하지 않다.
>    - 자바 힙이 다량의 객체로 가득 차 있고 그 대부분이 회수 대상이라면 표시하는 일도, 회수하는 일도 모두 커진다.
> 2. 메모리 파편화가 심하다.
>    - 가비지 컬렉터가 쓸고 간 자리에는 불연속적인 메모리 파편이 만들어진다.
>    - 파편화가 너무 심하면 프로그램이 큰 객체를 만들려 할 때 충분한 크기의 연속된 메모리를 찾기가 점점 어려워지고, 그 결과 또 다른 가비지 컬렉션을 유발한다.

### 3.3.3 마크-카피 알고리즘

- 가용 메모리를 똑같은 크기의 두 블록으로 나눠 한 번에 한 블록만 사용한다.
- 한쪽 블록이 꽉 차면 살아남은 객체들만 다른 블록에 복사하고 기존 블록을 한 번에 청소한다.

> 단점
> 1. 가용 메모리를 절반으로 줄여 낭비가 제법 심하다는 점이다.

> 아펠 스타일 컬렉션
> 1. 신세대를 하나의 큰 에덴 공간과 두 개의 작은 생존자 공간으로 나눈다.
> 2. 메모리를 할당할 때는 생존자 공간 중 하나와 에덴만 사용한다.
> 3. 가비지 컬렉션이 시작되면 에덴과 생존자 공간에서 살아남은 객체들을 나머지 생존자 공간으로 하나씩 복사한 후 에덴과 이전 생존자 공간을 곧바로 비운다.
> 
> 아펠 스타일 컬렉션의 특이 케이스에 대처하기 위한 설계. 메모리 할당 보증 메커니즘
> - 마이너 GC에서 살아남은 객체를 생존자 공간이 다 수용하지 못할 경우 다른 메모리 영역(대부분의 경우 구세대)을 활용해 메모리 할당을 보증하는 것이다(핸들 승격.

### 3.3.4 마크-컴팩트 알고리즘

- 마크-카피 알고리즘은 객체 생존율이 높을수록 복사할 게 많아져서 효율이 나빠진다.
- 표시 단계는 마크-스윕과 같다. 하지만 다음 컴팩트 단계에서 생존한 모든 객체를 메모리 영역의 한쪽 끝으로 모은 다음, 나머지 공간을 한꺼번에 비운다.
- 이런 식의 객체 이동은 사용자 애플리케이션을 모두 멈춘 상태에서 진행해야 하므로 신중하게 고려해야 할 단점이다. 이와 같은 일시 정지 현상을 초기 가상 머신 설계자는 'stop the world'라는 말로 아주 생생하게 표현해 냈다.

## 3.4 핫스팟 알고리즘 상세 구현

### 3.4.1 루트 노드 열거

- 도달 가능성 분석 알고리즘에서 GC 루트 집합으로부터 참조 체인을 찾는 작업을 말한다.

112p 부터 다시 진행.
