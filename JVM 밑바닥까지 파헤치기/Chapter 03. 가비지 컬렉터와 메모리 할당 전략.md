# Chapter 03. 가비지 컬렉터와 메모리 할당 전략

- 자바 힙과 메서드 영역은 불확실한 게 아주 많다.

## 3.2 대상이 죽었는가?

- 가비지 컬렉터가 힙을 청소하려면 가장 먼저 어떤 객체가 살아 있고, 또 어떤 객체가 죽었는지 판단해야 한다.
- '죽었다'는 말은 프로그램 코드에서 어떤 식으로도 더는 사용될 수 없다는 뜻이다.

### 3.2.1 참조 카운팅 알고리즘

> 객체가 살아 있는지 판단하는 알고리즘
> 1. 객체를 가리키는 참조 카운터를 추가한다. 참조하는 곳이 하나 늘어날 때마다 카운터 값을 1씩 증가시킨다.
> 2. 참조하는 곳이 하나 사라질 때마다 카운터 값을 1씩 감소시킨다.
> 3. 카운터 값이 0이 된 객체는 더는 사용될 수 없다.

- 간단한 참조 카운팅만으로는 수환 참조 문제를 풀기 어렵다.
- 자바 가상 머신은 객체 생사 판단에 참조 카운팅 알고리즘을 사용하지 않는다.

> JVM GC 로깅
> - -Xlog:gc*

### 3.2.2 도달 가능성 분석 알고리즘

- 자바, C# 등 오늘날의 주류 프로그래밍 언어들은 모두 객체 생사 판단에 도달 가능성 분석 알고리즘을 이용한다.
- 기본 아이디어는 GC 루트라고 하는 루트 객체들을 시작 노드 집합으로 쓰는 것이다.

> 탐색 과정
> 1. 시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색해 들어간다.
> 2. 탐색 과정에서 만들어지는 경로를 참조 체인이라 하는데, 어떤 객체와 GC 루트 사이를 이어 주는 참조 체인이 없다면, GC 루트로부터 도달 불가능한 객체는 더 이상 사용할 수 없는 게 확실해진다.

> 자바에서 GC 루트로 이용할 수 있는 객체
> - 가상 머신 스택에서 참조하는 객체: 현재 실행 중인 메서드에서 쓰는 매개 변수, 지역 변수, 임시 변수 등
> - 메서드 영역에서 클래스가 정적 필드로 참조하는 객체: 자바 클래스의 참조 타입 정적 변수
> - 메서드 영역에서 상수로 참조되는 객체: 문자열 테이블 안의 참조
> - 네이티브 메서드 스택에서 JNI(네이티브 메서드)가 참조하는 객체
> - 자바 가상 머신 내부에서 쓰이는 참조: 기본 데이터 타입에 해당하는 Class 객체, 일부 상주 예외 객체, 시스템 클래스 로더
> - 동기화 락으로 잠겨 있는 모든 객체
> - 자바 가상 머신 내부 상황을 반영하는 JMXBean: JVMTI에 등록된 콜백, 로컬 코드 캐시 등

### 3.2.3 다시 참조 이야기로

> JDK 1.2부터 참조 개념이 확장되어 참조를 네 가지로 구분하기 시작했다. 나열한 순서대로 강도가 약해진다.
> 1. 강한 참조: 가장 전통적인 정의의 참조를 뜻한다. 가비지 컬렉터가 절대 회수하지 않는다.
> 2. 부드러운 참조: 유용하지만 필수는 아닌 객체를 표현한다. 메모리 오버플로가 나기 직전에 두 번째 회수를 위한 회수 목록에 추가된다. SoftReference<> 클래스가 구현하다.
> 3. 약한 참조: 부드러운 참조와 비슷하지만 연결 강도가 더 약하다. 약한 참조뿐인 객체는 다음번 가비지 컬렉션까지만 살아 있다. WeakReference<> 클래스가 구현한다.
> 4. 유령 참조: 참조 중에서 가장 약하다. 객체 수명에 아무런 영향을 주지 않으며, 유령 참조를 통해 객체 인스턴스를 가져오는 것마저 불가능하다. 대상 객체가 회수 될 때 알림을 받기 위해 사용한다. PhantomReference<> 클래스가 구현하다.

> final 참조
> - 참조 강도는 약한 참조와 유령 참조 사이다.
> - finalize() 메서드를 구현한 객체는 모두 파이널 참조의 대상이 되어 별도의 큐에 등록된다.

### 3.2.3 살았나 죽었나?

- 도달 가능성 분석 알고리즘이 도달 불가능으로 판단한 객체라고 해서 반드시 죽어야 하는 건 아니다.
- 확실한 사망 선고를 내리려면 두 번의 표시(marking) 과정을 거쳐야 한다.
- 도달 가능성 분석으로 GC 루트와 연결된 참조 체인을 찾지 못한 객체에는 첫 번째 표시가 이루어지며 이어서 필터링이 진행된다. 필터링 조건은 종료자(finalize), 즉 'finalize()를 실행해야 하는 객체인가'이다.
- finalize()를 실행해야 하는 객체로 판명되는 F-Queue라는 대기열에 추가된다.
- 가능한 한 finalize()는 사용하지 말자.

### 3.2.5 메서드 영역 회수하기

- 메서드 영역의 가비지 컬렉션은 크게 두 가지를 회수한다. 더 이상 사용하지 않는 상수와 클래스다.

> 더 이상 쓰이지 않는 클래스는 다음 세 가지 조건을 만족한다.
> - 이 클래스의 인스턴스가 모두 회수되었다. 즉, 자바 힙에는 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
> - 이 클래스를 읽어 들인 클래스 로더가 회수되었다. 이 조건은 OSGi나 JSP 리로딩처럼 세심하게 설계된 대안 클래스 로더 없이는 충족하기 어렵다.
> - 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다.

- 자바 가상 머신은 위 세 조건에 부합하는 쓸모 없는 클래스들을 회수하도록 허용한다. 허용한다고 했지, 반드시 회수한다고 하지는 않았다.
- 핫스팟 가상 머신은 클래스 회수 여부를 제어할 수 있도록 -Xnoclassgc 매개 변수를 제공한다.

## 3.3 가비지 컬렉션 알고리즘

- 상세한 이론은 The Garbage Collection Handbook 자세히 참고 바람.
- 참조 카운팅 GC와 추적 GC로 나눌 수 있다.

### 3.3.1 세대 단위 컬렉션 이론

> 기본적으로 두 가지 가정이 뿌리를 이룬다.
> 1. 약한 세대 가설: 대다수 객체는 일찍 죽는다.
> 2. 강한 세대 가설: 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
