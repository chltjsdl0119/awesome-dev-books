# Chapter 13. 스프링 앱에서 트랜잭션 사용

- 데이터의 일관성이 없는 시나리오를 방지하려면 두 단계 모두 올바르게 실행되거나 둘 중 어느 하나도 실행되지 않아야 한다.

## 13.1 트랜잭션

- 작업을 모두 올바르게 실행하거나 전혀 실행하지 않을 수 있다. 이를 원자성이라 한다.
- 시나리오가 모두 성공적으로 실행되면 트랜잭션이 종료될 때 변경 사항을 유지한다. 이를 **커밋**이라 한다.
- 시나리오 중 하나라도 실패할 경우, 변경된 내용을 복원한다. 이를 **롤백**이라 한다.

## 13.2 스프링에서 트랜잭션의 작동 방식

- 트랜잭션 이면에는 스프링 AOP 애스펙트가 있다.
- 스프링이 트랜잭션에서 감싸길 원하는 메서드를 표시하기 위해 @Transactional이라는 어노테이션을 사용한다.
- @Transactional 어노테이션을 사용하면 스프링에서 구성한 애스펙트가 메서드 호출을 가로채고 해당 호출에 대한 트랜잭션 로직을 적용한다.
- 메서드가 런타임 에러를 발생시키면 앱은 메서드가 변경한 내용을 유지하지 않는다.(롤백)

> 자바에서 체크 예외란 처리하거나 던져야 하는 예외이다.
> - 메서드에서 예외가 발생하면 트랜잭션 롤백이 기본적으로 발생하지 않는다.

## 13.3 스프링 앱에서 트랜잭션 사용

- 트랜잭션은 서비스 메서드 실행 직전에 시작하고 메서드가 성공적으로 종료된 직후에 종료된다.
- 메서드에서 런타임 예외가 발생하지 않으면 앱은 트랜잭션을 커밋한다.
- 어떤 단계에서 런타임 예외가 발생하면 앱은 데이터를 트랜잭션이 시작되기 전 상태로 복원한다.
- @Transactional 어노테이션을 클래스에 직접 사용할 수도 있다. 해당 클래스의 모든 메서드에 적용된다.

> 두 앱 간 전송되는 데이터를 모델링하는 역할을 하는 객체를 DTO라고 한다.

> 제대로 테스트하지 않는 한 어떤 것도 작동한다고 믿어서는 안 된다. 앱의 모든 기능을 테스트하기 전까지 앱은 슈뢰딩거 상태에 있다.
> 상태를 증명하기 전까지 기능은 작동한 상태이기도 하고 작동하지 않는 상태이기도 하다.

## 13.4 요약

- 트랜잭션은 데이터를 변경하는 일련의 작업으로, 모두 실행되거나 전혀 실행되지 않도록 해준다. 데이터 불일치를 방지하고자 거의 모든 사용 사례가 트랜잭션 대상이 되어야 한다.
- 작업 중 하나라도 실패하면 앱은 데이터를 트랜잭션의 시작 시점 상태로 복원한다. 이런 상황이 발생할 때 트랜잭션이 롤백되었다고 한다.
- 모든 작업이 성공하면 트랜잭션이 커밋된다고 한다. 이는 앱이 사용 사례가 실행되어 수행된 모든 변경 사항을 유지한다는 의미이다.
- 스프링에서 트랜잭션 코드를 작성하려면 @Transactional 어노테이션을 사용하고, 이 어노테이션으로 스프링이 트랜잭션에 해당 메서드를 포함하도록 표시할 수 있다. 클래스에도 추가할 수 있다.
- 실행하면 스프링 애스펙트는 @Transactional 어노테이션이 달린 메서드를 가로챈다.