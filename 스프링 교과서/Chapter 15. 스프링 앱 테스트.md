# Chapter 15. 스프링 앱 테스트

- 테스트는 앱이 구현하는 특정 기능이 예상대로 작동하는 지 확인하는 것을 목적으로 하는 작은 로직이다.

> 테스트의 두 가지 범주
> - 단위 테스트: 격리된 로직 부분에만 집중한다.
> - 통합 테스트: 여러 구성 요소가 서로 올바르게 상호 작용하는지 검증하는 데 집중한다.

- 테스트는 모든 어플리케이션에 필수적이다.

> 기능을 수동으로 테스트하지 않고 테스트를 작성해야 하는 이유는 다음과 같다.
> - 테스트를 반복해서 실행하여 최소한의 노력으로 예상대로 작동하는지 검증할 수 있다.(앱이 지속적으로 올바르게 작동하는지 검증할 수 있다.)
> - 테스트 단계를 읽으면서 사용 사례 목적을 쉽게 이해할 수 있다.(문서화 역할을 한다.)
> - 테스트는 개발 과정에서 새로운 애플리케이션 문제에 대해 이른 피드백을 제공한다.

- 기능에 대한 테스트를 작성하면 앱을 변경할 때마다 테스트를 실행하여 예상대로 작동하는지 확인할 수 있다.
- 회귀 테스트(regression test)는 기존 기능을 지속적으로 테스트하여 여전히 올바르게 작동하는지 확인하는 방식이다.
- 지속적 통합 도구는 개발 프로세스 중에 구현한 앱을 빌드하고 설치하는 데 필요한 단계를 실행하려고 사용하는 소프트웨어다.

## 15.1 올바른 테스트 작성

- 테스트 가능성(testability)과 유지보수성(maintainability)은 상호보완적인 소프트웨어 품질 요소다.

## 15.2 스프링 앱에서 테스트 구현

### 15.2.1 단위 테스트 구현

#### 첫 번째 단위 테스트 구현하기

- 일반적으로 가장 확실한 시나리오이자 가장 먼저 테스트를 작성하는 것은 예외나 오류가 발생하지 않는 실행 시나리오인 **정상 플로(happy flow)** 이다.

> 모든 테스트는 다음 세 가지 주요 부분으로 구성된다. 다음 세 단계는 '준비(arrange)', '행동(act)', '단언(assert)' 또는 'given', 'when', 'then'으로 다르게 명명되는 경우도 있다. 
> 1. 가정(assumption): 원하는 시나리오 플로를 달성하려면 입력을 정의하고 제어해야 할 로직의 의존성을 찾아야 한다. 이를 위해 우리는 다음 두 가지 질문, 즉 어떤 입력을 제공해야 하는가와 테스트 대상 로직이 기대하는 특정한 방식으로 동작하려면 의존성이 어떻게 동작해야 하는지에 답할 것이다.
> 2. 호출/실행(call/execution): 테스트 대상 로직을 호출하여 동작을 검증해야 한다.
> 3. 유효성 검사(validations): 해당 로직에 대해 수행해야 하는 모든 유효성 검사를 정의해야 한다. 우리는 해당 로직이 주어진 조건에서 호출되면 어떤 일이 발생되는지 묻는 질문에 답할 수 있어야 한다.

- 작성하는 테스트의 테스트 케이스에 대한 의존성을 식별한다.

> 의존성이란?
> - 메서드가 사용하지만 자체적으로 생성하지 않는 모든 것.
> - 메서드의 매개변수
> - 메서드가 사용하지만 메서드로 생성되지 않는 객체

- 메서드의 매개변수와 메서드 내의 객체는 테스트를 위해 제어해야 하는 의존성이다.
- 단위 테스트는 주어진 방식으로 작동한다 가정하고 테스트 대상 메서드가 주어진 상황에서 예상되는 작업을 수행한다고 단언해야(assert) 한다.
- 메서드 내에서 어떤 객체의 메서드를 호출할 경우엔, 이런 의존성을 제어하고자 동작을 제어할 수 있는 가짜 객체인 모의(mock) 객체를 사용한다.

> - @Mock: 이 어노테이션을 사용하면 프레임워크가 어노테이션된 속성에 모의 객체를 생성하고 삽입할 수 있다.
> - @InjectMock: 이 어노테이션을 사용하면 테스트할 객체를 생성하고 프레임워크가 해당 매개변수에 모든 모의 객체(@Mock으로 생성된)를 주입하도록 지시한다.
> - 위 두 어노테이션이 작동하려면 클래스에 @ExtendWith(MockitoExtension.class) 어노테이션도 추가해야 한다.

> 단계 나열
> 1. 가정: 의존성을 나열하고 제어한다.
> 2. 호출: 테스트한 메서드를 실행한다.
> 3. 유효성 검사: 실행된 메서드가 예상 동작을 하는지 확인한다.

#### 예외 플로에 대한 테스트 작성하기

- 예외 플로(exception flow): 메서드가 예외를 만났을 때 기대한 방식으로 실행되는지 확인하는 플로.
- asserThrows()를 통해 예상된 예외를 던지는지 검증한다.

#### 메서드 반환 값 테스트하기

- assertEquals()를 통해 메서드가 반환한 값을 비교할 수 있다.

### 15.2.2 통합 테스트 구현

> 통합을 테스트할 수 있는 몇 가지 예
> - 앱 내의 객체 두 개(또는 그 이상) 간의 통합: 객체가 올바르게 상호 작용하는지 테스트하면, 객체 중 하나가 변경될 경우 협업하는 데 문제는 없는지 파악할 때 도움이 된다.
> - 프레임워크의 앱 향상 기능과 앱 객체의 통합: 프레임워크가 제공하는 기능과 상호 작용하는 방식을 테스트하면, 프레임워크를 새 버전으로 업그레이드할 때 생길 수 있는 문제를 발견하는 데 도움이 된다.
> - 앱과 영속성 계층(데이터베이스)의 통합: 레포지토리가 데이터베이스와 어떻게 작동하는지 테스트하면 앱이 영속 데이터(JDBC 드라이버)와 작업하는 데 도움을 주는 의존성을 업그레이드하거나 변경할 때 발생할 수 있는 문제를 신속하게 파악할 수 있다.

- 단위 테스트에선 레포지토리를 모의하는 것이 필수였지만, 통합테스트에서는 더 이상 필수가 아니다.

> 스프링 통합 테스트
> - 스프링 앱에서는 일반적으로 통합 테스트를 사용하여 앱의 동작이 스프링이 제공하는 기능과 올바르게 상호 작용하는지 확인하는 과정.

- @MockBean: 스프링 부트 어노테이션.

## 15.3 요약

- 테스트는 앱에 구현된 특정 로직의 동작을 검증하려고 작성하는 작은 코드다. 테스트는 향후 앱 개발에서 기존 기능을 손상시키지 않는 데 필요하며, 문서화에도 도움이 된다.
- 테스트는 단위 테스트와 통합 테스트 두 가지 범주로 나뉘며 자체의 목적이 있다.
  - 단위 테스트: 격리된 로직에만 초점을 맞추고 다른 기능과 하나의 간단한 구성 요소가 어떻게 작동하는지 검증한다. 빠르게 실행되고 특정 구성 요소가 직면할 수 있는 문제를 직접적으로 알려주기 때문에 유용하다.
  - 통합 테스트: 구성 요소 간 상호 작용을 검증하는 데 중점을 둔다. 두 구성 요소가 개별적으로는 올바르게 작동하지만 제대로 통신하지 않는 경우가 있기 때문에 통합 테스트는 필수다.
- 테스트에서 일부 구성 요소에 대한 의존성을 제거하여 모든 구성 요소가 아닌 일부 컴포넌트의 상호 작용 방식에 집중하고 싶을 때가 있다. 이 때는 테스트하고 싶지 않은 구성 요소를 모의(mocks) 객체로 대체한다. 모의 객체는 테스트를 원치 않는 의존성을 제거하고 테스트가 특정 상호 작용에만 집중할 수 있도록 제어하는 가짜 객체를 의미한다.
- 모든 테스트는 다음 세 가지 주요 부분으로 구성된다.
  - 가정: 입력 값과 모의 객체의 동작 방식을 정의한다.
  - 호출/실행: 테스트하려는 메서드를 호출한다.
  - 유효성 검사: 테스트한 메서드의 동작 방식을 확인한다.
