# Chapter 01. 어떤 알고리즘으로 풀어야 할까?

- 코딩 테스트의 핵심 중 하나는 문제마다 주어진 시간 복잡도를 고려해 적절한 알고리즘을 선택하는 것이다.

## 01-1 시간 복잡도 표기법 알아보기

- 알고리즘에서 시간 복잡도는 주어진 문제를 해결하기 위한 연산 횟수를 말한다. 일반적으로 수행 시간은 1억 번의 연산을 1초의 시간으로 간주하여 예측한다.

> 시간 복잡도 유형
> - 빅-오메가: 최선일 때 연산 횟수를 나타낸 표기법
> - 빅-세타: 보통일 때의 연산 횟수를 나타낸 표기법
> - 빅-오: 최악일 때의 연산 횟수를 나타낸 표기법

#### 시간 복잡도 예제 코드
#### 빅-오메가의 표기법의 시간 복잡도는 1번, 빅-세타 표기볍의 시간 복잡도는 N/2번, 빅-오 표기법의 시간 복잡도는 N번이다.
```java
public class Main {
    public static void main(String[] args) {

        int findNumber = (int)(Math.random() * 100);

        for (int i = 0; i < 100; i++) {
            if (i == findNumber) {
                System.out.println(i);
                break;
            }
        }
    }
}
```

- 코딩 테스트에서는 빅-오 표기법을 기준으로 수행 시간을 계산하는 것이 좋다.

## 01-2 시간 복잡도 활용하기

### 수 정렬하기

- 시간 제한이 2초이므로 이 조건을 만족하려면 2억 번 이하의 연산 횟수로 문제를 해결해야 한다.

> 연산 횟수 계산 방법
> - 연산 횟수 = 알고리즘 시간 복잡도 n앖에 데이터의 최대 크기를 대입하여 도출.

> 알고리즘 적합성 평가
> - 버블 정렬 = (1,000,000)² = 1,000,000,000,000 > 200,000,000 -> 부적합 알고리즘
> - 병합 정렬 = 1,000,000log(1,000,000) = 20,000,000 < 200,000,000 -> 적합 알고리즘

- 시간 제한이 2초이므로 연산 횟수 2억 번 안에 원하는 답을 구해야 한다.

> 시간 복잡도 도출 기준
> 1. 상수는 시간 복잡도 계산에서 제외한다.
> 2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

- 시간 복잡도는 가장 많이 중접된 반복문을 기준으로 도출한다.
