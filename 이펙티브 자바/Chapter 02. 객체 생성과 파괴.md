# Chapter 02. 객체 생성과 파괴

## Item 01. 생성자 대신 정적 팩터리 메서드를 고려하라

### 정적 팩터리 메서드의 장점

1. 이름을 가질 수 있다.
2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

### 정적 팩터리 메서드의 단점

1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 재공하면 하위 클래스를 만들 수 없다.
2. 프로그래머가 찾기 어렵다.

### 정적 팩터리 메서드 명명 방식

- from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드.
- of: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드.
- valueOf: from과 of의 더 자세한 버전.
- instance 혹은 getInstance: 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지 않는다.
- create 혹은 newInstance: instance 혹은 getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
- getType: getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
- newType: newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
- type: getType과 newType의 간결한 버전.

## Item 02. 생성자에 매개변수가 많다면 빌더를 고려하라

### 자바빈즈 패턴

- 매개변수가 없는 생성자로 객체를 만든 후, setter 메서드를 호출해 값을 설정하는 방식.
- 일관성이 깨지고, 불변으로 만들 수 없다.

### 빌더 패턴

- 점층적 생성자 패턴과 자바빈즈 패턴의 장점만 취했다.
- 메서드 호출이 흐르듯 연결된다는 뜻으로 플루언트 API 혹은 메서드 체이닝이라 한다.
- 계층적으로 설계된 클래스와 함께 쓰기에 좋다.
- 빌더 생성 비용이 크지는 않지만 성능에 민감한 상황에서는 문제가 될 수 있다.

### 정리

- 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는 게 더 낫다.
- 자바빈즈보다 훨씬 안전하다.

## Item 03. private 생성자나 열거 타입으로 싱글턴임을 보증하라

- 싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다.

### 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기 어려워질 수 있다.

- 타입을 인터페이스로 정의한 다음 그 인터페이스를 구현해서 만든 싱글턴이 아니라면 싱글턴 인스턴스를 가짜(mock) 구현으로 대체할 수 없기 때문이다.

## Item 04. 인스턴스화를 막으려거든 private 생성자를 사용하라

- 정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 게 아니다.
- private 생성자를 추가하여 클래스의 인스턴스화를 막는다.

## Item 05. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 사용하는 자원에 따라 동작이 달리지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
- 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식을 채택한다.

### 의존 객체 주입 패턴

- 유연성과 테스트 용이성을 높여준다.
- 불변을 보장한다.

### 정리

- 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다.

## Item 06. 불필요한 객체 생성을 피하라

- 똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다.
- 생성자는 호출할 때마다 새로운 객체를 만들지만, 팩터리 메서드는 전혀 그렇지 않다.

- 프로그램의 명확성, 간결성, 기능을 위해서 객체를 추가로 생성하는 것은 일반적으로 좋은 일이다.
- 아주 무거운 객체가 아닌 다음에야 단순히 객체 생성을 피하고자 객체 풀을 만들지는 말자.

## Item 07. 다 쓴 객체 참조를 해제하라

- 가비지 컬렉터를 갖춘 언어라 하더라도, 메모리 관리에 신경 서야 한다.
- 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.
- 다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위로 밀어내는 것이다.

## Item 08. finalizer와 cleaner 사용을 피하라

- finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.
- cleaner는 finalizer보다 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.
- 자바 언어 명세는 finalizer와 cleaner의 수행 시점 뿐만 아니라 수행 여부조차 보장하지 않는다.
- finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.

### 대안

- AutoCloseable 인터페이스를 구현해주고, 인스턴스를 다 쓰고 나면 close 메서드를 호출해 자원을 해제한다.
- 일반적으로 예외가 발생해도 종료하도록 try-with-resources 문을 사용한다.

### 정리

- cleaner는 안전망 역할이나 중요하지 않은 네이티브 자원회수용으로만 사용하자.

## Item 09. try-finally보다는 try-with-resources를 사용하라

### 정리

- 꼭 회수해야 하는 자원을 다룰 때는 try-finally보다는 try-with-resources를 사용하자.
