# Chapter 03. 모든 객체의 공통 메서드

- Object는 객체를 만들 수 있는 구체 클래스지만 기본적으로 상속해서 사용하도록 설계되었다.
- Object에서 final이 아닌 메서드는 모두 재정의를 염두에 두고 설계된 것이라 재정의 시 지켜야하는 규약이 명확히 정의되어 있다.

## Item 10. equals는 일반 규약을 지켜 재정의하라

- 재정의하기 쉬워 보이지만 곳곳에 함정이 도사리고 있어서 주의해야 한다.
- 문제를 회피하는 가장 쉬운 길은 아예 재정의하지 않는 것이다.

### 재정의해야 할 떄

- 객체 식별성이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때이다.
- equals가 논리적 동치성을 확인하도록 재정의해두면, 그 인스턴스는 값을 비교하길 원하는 프로그래머의 기대에 부응함은 물론 Map의 키와 Set의 원소로 사용할 수 있게 된다.

> 동치 관계는 다음을 만족한다.
> - 반사성
> - 대칭성
> - 추이성
> - 일관성
> - null 아님

### 주의 사항

- equals를 재정의할 땐 hashCode도 반드시 재정의해야 한다.
- 너무 복잡하게 해결하려 들지 말자. 필드들의 동치성만 검사해도 equals 규약을 어렵지 않게 지킬 수 있다.
- Object 타입 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자.

### 정리

- 꼭 필요한 경우가 아니라면 equals를 재정의하지 말자.
- 재정의해야 할 때는 그 클래스의 핵심 필드 모두를 빠짐없이, 다섯 가지 규약을 확실히 지켜가며 비교해야 한다.

## Item 11. equals를 재정의하려거든 hashCode도 재정의하라

- equals를 재정의한 클래스 모두에서 hashCode도 반드시 재정의해야 한다.
- 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.
- 이상적인 해시 함수는 주어진(서로 다른) 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다.
- 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안된다.

### 정리

- equals를 재정의할 때는 hashCode도 반드시 재정의해야 한다.
- 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 한다.

## Item 12. toString을 항상 재정의하라

- toString의 일반 규약에 따르면 '간결하면서 사람이 읽기 쉬운 형태의 유익한 정보'를 반환해야 한다.
- 또한 toString의 규약은 모든 하위 클래스에서 이 메서드를 재정의하라고 한다.
- 실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다.

### 정리

- 모든 구체 클래스에서 Object의 toString을 재정의하자.

## Item 13. clone 재정의는 주의해서 진행하라

- clone(), Cloneable 인터페이스에 대해 좀 더 학습합시다.

### 정리

- 새로운 인터페이스를 만들 때는 절대 Cloneable 인터페이스를 확장해서는 안된다. 새로운 클래스도 구현해서는 안된다.
- 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용해야 한다.
- 기본 원칙은 '복제 기능은 생성자와 팩터리를 이용하는 게 최고'라는 것이다.
- 배열만은 clone 메서드 방식이 가장 깔끔한, 이 규칙의 합당한 예외라 할 수 있다.

## Item 14. Comparable을 구현할지 고려하라

- Comparable을 구현했다는 것은 그 클랫의 인스턴스들에는 자연적인 순서가 있음을 뜻한다.
- 알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면 반드시 Comparable 인터페이스를 구현하자.
- compareTo 메서드로 수행하는 동치성 검사도 equals 규약과 똑같이 반사성, 대칭성, 추이성을 충족해야 한다.
- compareTo 메서드로 수행하는 동치성 결과가 equals와 같아야 한다.
- compareTo 메서드에서 관계 연산자 < 와 > 를 사용하는 이전 방식은 거추장스럽고 오류를 유발하니 이제는 추천하지 않는다.

### 정리

- 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여, 그 인스턴스들을 쉽게 정렬하고, 검색하고, 비교 기능을 제공하는 컬렉션과 어우러지도록 해야 한다.
- compareTo 메서드에서 필드의 값을 비교할 때 < 와 > 연산자는 쓰지 말아야 한다. 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare 메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.
