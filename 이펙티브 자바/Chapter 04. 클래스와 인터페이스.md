# Chapter 04. 클래스와 인터페이스

## Item 15. 클래스와 멤버의 접근 권한을 최소화하라

- 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다.
- 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다.
- 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.

### 정리

- 프로그램 요소의 접근성은 가능한 한 최소한으로 하라.
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안된다.

## Item 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

### 정리

- public 클래스는 절대 가변 필드를 노출해서는 안된다.
- 불변 필드라면 덜 위험하지만, 완전히 안심할 수는 없다.

## Item 17. 변경 가능성을 최소화하라

### 불변 클래스의 다섯 가지 규칙

1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다.
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private으로 선언한다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

- 불변 객체는 단순하다. 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다.
- 불변 객체는 여러 스레드가 동시에 사용해도 절대 훼손되지 않는다.
- 가변 객체는 임의의 복잡한 상태에 놓일 수 있다.

- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.

## Item 18. 상속보다는 컴포지션을 사용하라

- 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.
- 상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 쓰여야 한다. 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 한다.

### 정리

- 상속은 강력하지만 캡슐화를 해친다는 문제가 있다.
- 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야 한다.
- is-a 관계일 때도, 상위 클래스가 확장을 고려해 설계되었을 때 상속해야 한다.
- 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자.

## Item 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.

> 좋은 API 문서랑 '어떻게'가 아닌 '무엇'을 하는지를 설명해야 한다.

- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
- Cloneable 과 Serializable 인터페이스는 상속용 설계의 어려움을 한층 더해준다.

### 정리

- 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다.
- 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.

## Item 20. 추상 클래스보다는 인터페이스를 우선하라

- 인터페이스는 믹스인 정의에 안성맞춤이다.
- 추상 클래스로는 믹스인을 정의할 수 없다.

> 믹스인이란?
> - 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 '주된 타입' 외에도 특정 선택적 행위를 제공한다고 선언하는 효과.

- 인터페이스 메서드 중 구현 방법이 명백한 것이 있다면, 그 구현을 디폴트 메서드로 제공해준다.
- 디폴트 메서드를 제공할 때는 상속하려는 사람을 위한 설명을 @implSpec 자바독 태그를 붙여 문서화해야 한다.
